{
	// Place your KernelSnippets workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Linux Kernel Module Init": {
		"scope": "c",
		"prefix": "kmodinit",
		"body": [
			"// SPDX-License-Identifier: GPL-2.0",
			"/*",
			" * ${2:description}",
			" *",
			" * Copyright (C) ${4:${CURRENT_YEAR}} ${1:author}",
			" */",
			"",
			"#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
			"",
			"#include <linux/module.h>",
			"#include <linux/kernel.h>",
			"#include <linux/init.h>",
			"",
			"static char param_str[128] = \"default\";",
			"module_param_string(param_str, param_str, sizeof(param_str), 0644);",
			"MODULE_PARM_DESC(param_str, \"A string module parameter\");",
			"",
			"static int __init ${3:${TM_FILENAME_BASE}}_init(void)",
			"{",
			"\tpr_info(\"loaded, param_str=%s\\n\", param_str);",
			"\treturn 0;",
			"}",
			"",
			"static void __exit ${3:${TM_FILENAME_BASE}}_exit(void)",
			"{",
			"\tpr_info(\"unloaded\\n\");",
			"}",
			"",
			"module_init(${3:${TM_FILENAME_BASE}}_init);",
			"module_exit(${3:${TM_FILENAME_BASE}}_exit);",
			"",
			"MODULE_LICENSE(\"GPL\");",
			"MODULE_AUTHOR(\"${1:author}\");",
			"MODULE_DESCRIPTION(\"${2:description}\");",
			"MODULE_VERSION(\"1.0\");",
			""
		],
		"description": "Linux kernel module initialization template with module_param_string example (checkpatch compliant, SPDX, pr_fmt uses KBUILD_MODNAME, filename as module name, MODULE_* at end)"
	},
	"Linux Kernel Module with /proc entry": {
		"scope": "c",
		"prefix": "kmodproc",
		"body": [
			"// SPDX-License-Identifier: GPL-2.0",
			"/*",
			" * ${2:description} (/proc entry example, read/write)",
			" *",
			" * Copyright (C) ${4:${CURRENT_YEAR}} ${1:author}",
			" */",
			"",
			"#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
			"",
			"#include <linux/module.h>",
			"#include <linux/kernel.h>",
			"#include <linux/init.h>",
			"#include <linux/proc_fs.h>",
			"#include <linux/seq_file.h>",
			"#include <linux/uaccess.h>",
			"#include <linux/spinlock.h>",
			"",
			"#define PROC_DATA_LEN\t128",
			"",
			"static struct proc_dir_entry *proc_entry;",
			"static char proc_data[PROC_DATA_LEN] = \"default\";",
			"static DEFINE_SPINLOCK(proc_data_lock);",
			"",
			"static int proc_show(struct seq_file *m, void *v)",
			"{",
			"\tunsigned long flags;",
			"\tchar buf[PROC_DATA_LEN];",
			"",
			"\tspin_lock_irqsave(&proc_data_lock, flags);",
			"\tstrscpy(buf, proc_data, sizeof(buf));",
			"\tspin_unlock_irqrestore(&proc_data_lock, flags);",
			"",
			"\tseq_printf(m, \"Current value: %s\\n\", buf);",
			"\treturn 0;",
			"}",
			"",
			"static ssize_t proc_write(struct file *file, const char __user *buffer,",
			"\t\t\t   size_t count, loff_t *ppos)",
			"{",
			"\tchar tmp[PROC_DATA_LEN];",
			"\tsize_t len;",
			"\tunsigned long flags;",
			"",
			"\tif (count == 0)",
			"\t\treturn 0;",
			"",
			"\tlen = min(count, sizeof(tmp) - 1);",
			"\tif (copy_from_user(tmp, buffer, len))",
			"\t\treturn -EFAULT;",
			"",
			"\ttmp[len] = '\\0';",
			"\t/* Remove trailing newline if present */",
			"\tif (len > 0 && tmp[len - 1] == '\\n')",
			"\t\ttmp[len - 1] = '\\0';",
			"",
			"\tspin_lock_irqsave(&proc_data_lock, flags);",
			"\tstrscpy(proc_data, tmp, sizeof(proc_data));",
			"\tspin_unlock_irqrestore(&proc_data_lock, flags);",
			"",
			"\tpr_info(\"/proc/${5:myprocfile} written: %s\\n\", proc_data);",
			"\t/* Additional processing of proc_data can be done here */",
			"\treturn count;",
			"}",
			"",
			"static int proc_open(struct inode *inode, struct file *file)",
			"{",
			"\treturn single_open(file, proc_show, NULL);",
			"}",
			"",
			"static const struct proc_ops proc_fops = {",
			"\t.proc_open\t= proc_open,",
			"\t.proc_read\t= seq_read,",
			"\t.proc_write\t= proc_write,",
			"\t.proc_lseek\t= seq_lseek,",
			"\t.proc_release\t= single_release,",
			"};",
			"",
			"static int __init ${3:${TM_FILENAME_BASE}}_init(void)",
			"{",
			"\tproc_entry = proc_create(\"${5:myprocfile}\", 0644, NULL, &proc_fops);",
			"\tif (!proc_entry) {",
			"\t\tpr_err(\"Failed to create /proc/${5:myprocfile}\\n\");",
			"\t\treturn -ENOMEM;",
			"\t}",
			"",
			"\tpr_info(\"/proc/${5:myprocfile} created\\n\");",
			"\treturn 0;",
			"}",
			"",
			"static void __exit ${3:${TM_FILENAME_BASE}}_exit(void)",
			"{",
			"\tif (proc_entry)",
			"\t\tproc_remove(proc_entry);",
			"\tpr_info(\"/proc/${5:myprocfile} removed\\n\");",
			"}",
			"",
			"module_init(${3:${TM_FILENAME_BASE}}_init);",
			"module_exit(${3:${TM_FILENAME_BASE}}_exit);",
			"",
			"MODULE_LICENSE(\"GPL\");",
			"MODULE_AUTHOR(\"${1:author}\");",
			"MODULE_DESCRIPTION(\"${2:description} (/proc entry example, read/write)\");",
			"MODULE_VERSION(\"1.0\");",
			""
		],
		"description": "Linux kernel module template with /proc file entry (proc_create, seq_file, read/write, locking, cleanup, modern proc_ops, strscpy)"
	},
	"Linux Kernel Module with Simple Kprobe": {
		"scope": "c",
		"prefix": "kmodsimplekprobe",
		"body": [
			"// SPDX-License-Identifier: GPL-2.0",
			"/*",
			" * ${2:description} (simple kprobe example)",
			" *",
			" * Copyright (C) ${4:${CURRENT_YEAR}} ${1:author}",
			" */",
			"",
			"#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
			"",
			"#include <linux/module.h>",
			"#include <linux/kernel.h>",
			"#include <linux/init.h>",
			"#include <linux/kprobes.h>",
			"#include <linux/ptrace.h>",
			"#include <linux/sched.h>",
			"",
			"static char target_func[64] = \"${5:sys_openat}\";",
			"module_param_string(target_func, target_func, sizeof(target_func), 0644);",
			"MODULE_PARM_DESC(target_func, \"Target function to probe\");",
			"",
			"static struct kprobe kp = {",
			"\t.symbol_name = target_func,",
			"};",
			"",
			"/* 在目标函数入口处被调用 */",
			"static int kprobe_handler(struct kprobe *p, struct pt_regs *regs)",
			"{",
			"\tpr_info(\"<%s> called by pid=%d comm=%s\\n\",",
			"\t\tp->symbol_name, current->pid, current->comm);",
			"",
			"\t/* 获取函数参数 (x86_64) */",
			"\t/* arg0=regs->di, arg1=regs->si, arg2=regs->dx, etc. */",
			"",
			"\treturn 0;",
			"}",
			"",
			"static int __init ${3:${TM_FILENAME_BASE}}_init(void)",
			"{",
			"\tint ret;",
			"",
			"\tkp.pre_handler = kprobe_handler;",
			"",
			"\tret = register_kprobe(&kp);",
			"\tif (ret < 0) {",
			"\t\tpr_err(\"register_kprobe failed, returned %d\\n\", ret);",
			"\t\treturn ret;",
			"\t}",
			"",
			"\tpr_info(\"Planted kprobe at %p (symbol: %s)\\n\", kp.addr, kp.symbol_name);",
			"\treturn 0;",
			"}",
			"",
			"static void __exit ${3:${TM_FILENAME_BASE}}_exit(void)",
			"{",
			"\tunregister_kprobe(&kp);",
			"\tpr_info(\"kprobe at %p unregistered\\n\", kp.addr);",
			"}",
			"",
			"MODULE_LICENSE(\"GPL\");",
			"MODULE_AUTHOR(\"${1:author}\");",
			"MODULE_DESCRIPTION(\"${2:description} (simple kprobe example)\");",
			"",
			"module_init(${3:${TM_FILENAME_BASE}}_init);",
			"module_exit(${3:${TM_FILENAME_BASE}}_exit);",
			""
		],
		"description": "Simple Linux kernel module template with kprobe (pre_handler only) for function entry monitoring"
	},
	"Linux Kernel Module with Kretprobe": {
		"scope": "c",
		"prefix": "kmodkretprobe",
		"body": [
			"// SPDX-License-Identifier: GPL-2.0",
			"/*",
			" * ${2:description} (kretprobe example)",
			" *",
			" * Copyright (C) ${4:${CURRENT_YEAR}} ${1:author}",
			" */",
			"",
			"#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
			"",
			"#include <linux/module.h>",
			"#include <linux/kernel.h>",
			"#include <linux/init.h>",
			"#include <linux/kprobes.h>",
			"#include <linux/ptrace.h>",
			"#include <linux/sched.h>",
			"#include <linux/string.h>",
			"#include <linux/time.h>",
			"",
			"static char target_func[64] = \"${5:vfs_read}\";",
			"module_param_string(target_func, target_func, sizeof(target_func), 0644);",
			"MODULE_PARM_DESC(target_func, \"Target function to probe\");",
			"",
			"static struct kretprobe rp = {",
			"\t.kp.symbol_name = target_func,",
			"\t.maxactive = 20,\t\t/* 最大活跃实例数 */",
			"\t.data_size = sizeof(ktime_t),\t/* 每个实例的私有数据大小 */",
			"};",
			"",
			"/* kretprobe entry handler: called when the probed function is entered */",
			"static int entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)",
			"{",
			"\tktime_t *entry_time = (ktime_t *)ri->data;",
			"",
			"\t*entry_time = ktime_get();",
			"",
			"\tpr_info(\"<%s> entry: pid=%d comm=%s\\n\",",
			"\t\trp.kp.symbol_name, current->pid, current->comm);",
			"",
			"\t/* 可以在这里记录函数参数 */",
			"\t/* 例如对于 vfs_read: */",
			"\t/*",
			"\t * struct file *file = (struct file *)regs->di;",
			"\t * size_t count = (size_t)regs->dx;",
			"\t * pr_info(\"vfs_read: count=%zu\\n\", count);",
			"\t */",
			"",
			"\treturn 0;",
			"}",
			"",
			"/* kretprobe return handler: called when the probed function returns */",
			"static int ret_handler(struct kretprobe_instance *ri, struct pt_regs *regs)",
			"{",
			"\tktime_t *entry_time = (ktime_t *)ri->data;",
			"\tktime_t exit_time, duration;",
			"\tlong ret_val = regs_return_value(regs);",
			"",
			"\texit_time = ktime_get();",
			"\tduration = ktime_sub(exit_time, *entry_time);",
			"",
			"\tpr_info(\"<%s> return: pid=%d comm=%s ret=%ld duration=%lld ns\\n\",",
			"\t\trp.kp.symbol_name, current->pid, current->comm,",
			"\t\tret_val, ktime_to_ns(duration));",
			"",
			"\treturn 0;",
			"}",
			"",
			"static int __init ${3:${TM_FILENAME_BASE}}_init(void)",
			"{",
			"\tint ret;",
			"",
			"\trp.entry_handler = entry_handler;",
			"\trp.handler = ret_handler;",
			"",
			"\tret = register_kretprobe(&rp);",
			"\tif (ret < 0) {",
			"\t\tpr_err(\"register_kretprobe failed, returned %d\\n\", ret);",
			"\t\treturn ret;",
			"\t}",
			"",
			"\tpr_info(\"Planted kretprobe at %p (symbol: %s)\\n\",",
			"\t\trp.kp.addr, rp.kp.symbol_name);",
			"\treturn 0;",
			"}",
			"",
			"static void __exit ${3:${TM_FILENAME_BASE}}_exit(void)",
			"{",
			"\tunregister_kretprobe(&rp);",
			"\tpr_info(\"kretprobe at %p unregistered, missed %d instances\\n\",",
			"\t\trp.kp.addr, rp.nmissed);",
			"}",
			"",
			"MODULE_LICENSE(\"GPL\");",
			"MODULE_AUTHOR(\"${1:author}\");",
			"MODULE_DESCRIPTION(\"${2:description} (kretprobe example with timing)\");",
			"",
			"module_init(${3:${TM_FILENAME_BASE}}_init);",
			"module_exit(${3:${TM_FILENAME_BASE}}_exit);",
			""
		],
		"description": "Linux kernel module template with kretprobe for function entry/exit monitoring with timing analysis"
	},
	"Linux Kernel Module Makefile": {
		"scope": "makefile",
		"prefix": "kmodmake",
		"body": [
			"# Kernel module Makefile (multi-module & subdir support)",
			"",
			"KDIR := /lib/modules/$(shell uname -r)/build",
			"PWD := $(shell pwd)",
			"# List your module names here. e.g. MODULES := foo bar",
			"MODULES := ${1:foo bar}",
			"",
			"# For simple modules (e.g., 'foo' from 'src/foo.c'), no extra config is needed.",
			"# For modules with multiple source files, define <mod>-objs manually before this block.",
			"# Example: bar-objs := src/bar/main.o src/bar/utils.o",
			"",
			"# Generate obj-m for all modules and set default sources for simple ones.",
			"obj-m := $(addsuffix .o, $(MODULES))",
			"$(foreach m,$(MODULES),$(if $(filter-out undefined,$(origin $(m)-objs)),,$(eval $(m)-objs := src/$(m).o)))",
			"",
			"ccflags-y := -Wall -Werror -I$(PWD)/include",
			"",
			"CHECKPATCH := /usr/src/kernels/$(shell uname -r)/scripts/checkpatch.pl",
			"SRC := $(shell find . -name '*.c' -o -name '*.h' | grep -v '.mod.c$$')",
			".PHONY: all clean checkpatch modules_install help info logs",
			".PHONY: insmod rmmod reload status",
			"",
			"all: clean checkpatch modules",
			"",
			"modules:",
			"\t@echo \"Building kernel modules: $(MODULES)...\"",
			"\tmake -C $(KDIR) M=$(PWD) modules",
			"\t@echo \"Build completed: $(foreach m,$(MODULES),$(m).ko )\"",
			"",
			"checkpatch:",
			"\t@echo \"Running checkpatch on source files...\"",
			"\t@if [ -f $(CHECKPATCH) ]; then \\",
			"\t\techo \"Checking $(SRC)...\"; \\",
			"\t\t$(CHECKPATCH) --no-tree --terse -f $(SRC) || true; \\",
			"\telse \\",
			"\t\techo \"checkpatch.pl not found: skipped\"; \\",
			"\tfi",
			"",
			"clean:",
			"\t@echo \"Cleaning build files...\"",
			"\tmake -C $(KDIR) M=$(PWD) clean",
			"",
			"# Install all modules to system (requires root)",
			"modules_install: modules",
			"\tmake -C $(KDIR) M=$(PWD) modules_install",
			"\tdepmod -a",
			"",
			"# Load all modules (insmod)",
			"insmod: modules",
			"\t@for m in $(MODULES); do \\",
			"\t\techo \"Loading module $$$m...\"; \\",
			"\t\tif lsmod | grep -q '^'$$$m' '; then \\",
			"\t\t\techo \"Module $$$m already loaded, removing first...\"; \\",
			"\t\t\tsudo rmmod $$$m 2>/dev/null || true; \\",
			"\t\tfi; \\",
			"\t\tsudo insmod $$$m.ko; \\",
			"\t\techo \"Module $$$m loaded successfully\"; \\",
			"\t\tlsmod | grep '^'$$$m' ' || echo \"Warning: Module not found in lsmod\"; \\",
			"\tdone",
			"",
			"# Unload all modules (rmmod)",
			"rmmod:",
			"\t@for m in $(MODULES); do \\",
			"\t\techo \"Unloading module $$$m...\"; \\",
			"\t\tif lsmod | grep -q '^'$$$m' '; then \\",
			"\t\t\tsudo rmmod $$$m; \\",
			"\t\t\techo \"Module $$$m unloaded successfully\"; \\",
			"\t\telse \\",
			"\t\t\techo \"Module $$$m is not loaded\"; \\",
			"\t\tfi; \\",
			"\tdone",
			"",
			"# Reload all modules",
			"reload: rmmod insmod",
			"",
			"# Show status for all modules",
			"status:",
			"\t@echo \"=== Module Status ===\"",
			"\t@for m in $(MODULES); do \\",
			"\t\tif lsmod | grep -q '^'$$$m' '; then \\",
			"\t\techo \"✓ Module $$$m is loaded:\"; \\",
			"\t\tlsmod | grep '^'$$$m' '; \\",
			"\t\telse \\",
			"\t\techo \"✗ Module $$$m is not loaded\"; \\",
			"\t\tfi; \\",
			"\tdone",
			"",
			"# Show info for all modules",
			"info:",
			"\t@echo \"=== Module Information ===\"",
			"\t@for m in $(MODULES); do \\",
			"\t\tif [ -f $$$m.ko ]; then \\",
			"\t\t\tmodinfo $$$m.ko; \\",
			"\t\telse \\",
			"\t\t\techo \"Module $$$m.ko not found. Run 'make' first.\"; \\",
			"\t\tfi; \\",
			"\tdone",
			"",
			"# Show recent kernel logs for all modules",
			"logs:",
			"\t@echo \"=== Recent kernel logs (last 20 lines, filtered) ===\"",
			"\t@for m in $(MODULES); do \\",
			"\t\techo \"--- $$$m ---\"; \\",
			"\t\tdmesg | grep -i -w $$$m | tail -20 || echo \"No logs found for $$$m\"; \\",
			"\tdone",
			"",
			"# Show help",
			"help:",
			"\t@echo \"Available targets:\"",
			"\t@echo \"  all           - Run checkpatch and build modules (default)\"",
			"\t@echo \"  modules       - Build the kernel modules\"",
			"\t@echo \"  checkpatch    - Run kernel coding style checker\"",
			"\t@echo \"  clean         - Clean build files\"",
			"\t@echo \"  modules_install - Install modules to system\"",
			"\t@echo \"  insmod        - Load modules into kernel\"",
			"\t@echo \"  rmmod         - Unload modules from kernel\"",
			"\t@echo \"  reload        - Unload and reload modules\"",
			"\t@echo \"  status        - Show module load status\"",
			"\t@echo \"  info          - Show module information\"",
			"\t@echo \"  logs          - Show recent kernel logs for modules\"",
			"\t@echo \"  help          - Show this help message\"",
			"\t@echo \"\"",
			"\t@echo \"Modules: $(MODULES)\"",
			"\t@echo \"Kernel build dir: $(KDIR)\"",
			"",
		],
		"description": "Makefile 片段，支持多内核模块和子目录源文件，自动 obj-m，递归查找源文件，批量 insmod/rmmod/info/logs，适合复杂项目结构"
	}
}