{
	// Place your KernelSnippets workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Linux Kernel Module Init": {
		"scope": "c",
		"prefix": "kmodinit",
		"body": [
			"// SPDX-License-Identifier: GPL-2.0",
			"/*",
			" * ${3:${TM_FILENAME_BASE}}.c - ${2:description}",
			" *",
			" * Copyright (C) ${4:${CURRENT_YEAR}} ${1:author}",
			" */",
			"",
			"#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
			"",
			"#include <linux/module.h>",
			"#include <linux/kernel.h>",
			"#include <linux/init.h>",
			"",
			"static char param_str[128] = \"default\";",
			"module_param_string(param_str, param_str, sizeof(param_str), 0644);",
			"MODULE_PARM_DESC(param_str, \"A string module parameter\");",
			"",
			"static int __init ${3:${TM_FILENAME_BASE}}_init(void)",
			"{",
			"\tpr_info(\"loaded, param_str=%s\\n\", param_str);",
			"\treturn 0;",
			"}",
			"",
			"static void __exit ${3:${TM_FILENAME_BASE}}_exit(void)",
			"{",
			"\tpr_info(\"unloaded\\n\");",
			"}",
			"",
			"module_init(${3:${TM_FILENAME_BASE}}_init);",
			"module_exit(${3:${TM_FILENAME_BASE}}_exit);",
			"",
			"MODULE_LICENSE(\"GPL\");",
			"MODULE_AUTHOR(\"${1:author}\");",
			"MODULE_DESCRIPTION(\"${2:description}\");",
			"MODULE_VERSION(\"1.0\");"
		],
		"description": "Linux kernel module initialization template with module_param_string example (checkpatch compliant, SPDX, pr_fmt uses KBUILD_MODNAME, filename as module name, MODULE_* at end)"
	},
	"Linux Kernel Module with /proc entry": {
		"scope": "c",
		"prefix": "kmodproc",
		"body": [
			"// SPDX-License-Identifier: GPL-2.0",
			"/*",
			" * ${3:${TM_FILENAME_BASE}}.c - ${2:description} (/proc entry example, read/write)",
			" *",
			" * Copyright (C) ${4:${CURRENT_YEAR}} ${1:author}",
			" */",
			"",
			"#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
			"",
			"#include <linux/module.h>",
			"#include <linux/kernel.h>",
			"#include <linux/init.h>",
			"#include <linux/proc_fs.h>",
			"#include <linux/seq_file.h>",
			"#include <linux/uaccess.h>",
			"#include <linux/spinlock.h>",
			"",
			"#define PROC_DATA_LEN\t128",
			"",
			"static struct proc_dir_entry *proc_entry;",
			"static char proc_data[PROC_DATA_LEN] = \"default\";",
			"static DEFINE_SPINLOCK(proc_data_lock);",
			"",
			"static int proc_show(struct seq_file *m, void *v)",
			"{",
			"\tunsigned long flags;",
			"\tchar buf[PROC_DATA_LEN];",
			"",
			"\tspin_lock_irqsave(&proc_data_lock, flags);",
			"\tstrscpy(buf, proc_data, sizeof(buf));",
			"\tspin_unlock_irqrestore(&proc_data_lock, flags);",
			"",
			"\tseq_printf(m, \"Current value: %s\\n\", buf);",
			"\treturn 0;",
			"}",
			"",
			"static ssize_t proc_write(struct file *file, const char __user *buffer,",
			"\t\t\t   size_t count, loff_t *ppos)",
			"{",
			"\tchar tmp[PROC_DATA_LEN];",
			"\tsize_t len;",
			"\tunsigned long flags;",
			"",
			"\tif (count == 0)",
			"\t\treturn 0;",
			"",
			"\tlen = min(count, sizeof(tmp) - 1);",
			"\tif (copy_from_user(tmp, buffer, len))",
			"\t\treturn -EFAULT;",
			"",
			"\ttmp[len] = '\\0';",
			"\t/* Remove trailing newline if present */",
			"\tif (len > 0 && tmp[len - 1] == '\\n')",
			"\t\ttmp[len - 1] = '\\0';",
			"",
			"\tspin_lock_irqsave(&proc_data_lock, flags);",
			"\tstrscpy(proc_data, tmp, sizeof(proc_data));",
			"\tspin_unlock_irqrestore(&proc_data_lock, flags);",
			"",
			"\tpr_info(\"/proc/${5:myprocfile} written: %s\\n\", proc_data);",
			"\t/* Additional processing of proc_data can be done here */",
			"\treturn count;",
			"}",
			"",
			"static int proc_open(struct inode *inode, struct file *file)",
			"{",
			"\treturn single_open(file, proc_show, NULL);",
			"}",
			"",
			"static const struct proc_ops proc_fops = {",
			"\t.proc_open\t= proc_open,",
			"\t.proc_read\t= seq_read,",
			"\t.proc_write\t= proc_write,",
			"\t.proc_lseek\t= seq_lseek,",
			"\t.proc_release\t= single_release,",
			"};",
			"",
			"static int __init ${3:${TM_FILENAME_BASE}}_init(void)",
			"{",
			"\tproc_entry = proc_create(\"${5:myprocfile}\", 0644, NULL, &proc_fops);",
			"\tif (!proc_entry) {",
			"\t\tpr_err(\"Failed to create /proc/${5:myprocfile}\\n\");",
			"\t\treturn -ENOMEM;",
			"\t}",
			"",
			"\tpr_info(\"/proc/${5:myprocfile} created\\n\");",
			"\treturn 0;",
			"}",
			"",
			"static void __exit ${3:${TM_FILENAME_BASE}}_exit(void)",
			"{",
			"\tif (proc_entry)",
			"\t\tproc_remove(proc_entry);",
			"\tpr_info(\"/proc/${5:myprocfile} removed\\n\");",
			"}",
			"",
			"module_init(${3:${TM_FILENAME_BASE}}_init);",
			"module_exit(${3:${TM_FILENAME_BASE}}_exit);",
			"",
			"MODULE_LICENSE(\"GPL\");",
			"MODULE_AUTHOR(\"${1:author}\");",
			"MODULE_DESCRIPTION(\"${2:description} (/proc entry example, read/write)\");",
			"MODULE_VERSION(\"1.0\");"
		],
		"description": "Linux kernel module template with /proc file entry (proc_create, seq_file, read/write, locking, cleanup, modern proc_ops, strscpy)"
	},
	"Linux Kernel Module with Simple Kprobe": {
		"scope": "c",
		"prefix": "kmodsimplekprobe",
		"body": [
			"// SPDX-License-Identifier: GPL-2.0",
			"/*",
			" * ${3:${TM_FILENAME_BASE}}.c - ${2:description} (simple kprobe example)",
			" *",
			" * Copyright (C) ${4:${CURRENT_YEAR}} ${1:author}",
			" */",
			"",
			"#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
			"",
			"#include <linux/module.h>",
			"#include <linux/kernel.h>",
			"#include <linux/init.h>",
			"#include <linux/kprobes.h>",
			"#include <linux/ptrace.h>",
			"#include <linux/sched.h>",
			"",
			"static char target_func[64] = \"${5:sys_openat}\";",
			"module_param_string(target_func, target_func, sizeof(target_func), 0644);",
			"MODULE_PARM_DESC(target_func, \"Target function to probe\");",
			"",
			"static struct kprobe kp = {",
			"\t.symbol_name = target_func,",
			"};",
			"",
			"/* 在目标函数入口处被调用 */",
			"static int kprobe_handler(struct kprobe *p, struct pt_regs *regs)",
			"{",
			"\tpr_info(\"<%s> called by pid=%d comm=%s\\n\",",
			"\t\tp->symbol_name, current->pid, current->comm);",
			"",
			"\t/* 获取函数参数 (x86_64) */",
			"\t/* arg0=regs->di, arg1=regs->si, arg2=regs->dx, etc. */",
			"",
			"\treturn 0;",
			"}",
			"",
			"static int __init ${3:${TM_FILENAME_BASE}}_init(void)",
			"{",
			"\tint ret;",
			"",
			"\tkp.pre_handler = kprobe_handler;",
			"",
			"\tret = register_kprobe(&kp);",
			"\tif (ret < 0) {",
			"\t\tpr_err(\"register_kprobe failed, returned %d\\n\", ret);",
			"\t\treturn ret;",
			"\t}",
			"",
			"\tpr_info(\"Planted kprobe at %p (symbol: %s)\\n\", kp.addr, kp.symbol_name);",
			"\treturn 0;",
			"}",
			"",
			"static void __exit ${3:${TM_FILENAME_BASE}}_exit(void)",
			"{",
			"\tunregister_kprobe(&kp);",
			"\tpr_info(\"kprobe at %p unregistered\\n\", kp.addr);",
			"}",
			"",
			"MODULE_LICENSE(\"GPL\");",
			"MODULE_AUTHOR(\"${1:author}\");",
			"MODULE_DESCRIPTION(\"${2:description} (simple kprobe example)\");",
			"",
			"module_init(${3:${TM_FILENAME_BASE}}_init);",
			"module_exit(${3:${TM_FILENAME_BASE}}_exit);"
		],
		"description": "Simple Linux kernel module template with kprobe (pre_handler only) for function entry monitoring"
	},
	"Linux Kernel Module with Kretprobe": {
		"scope": "c",
		"prefix": "kmodkretprobe",
		"body": [
			"// SPDX-License-Identifier: GPL-2.0",
			"/*",
			" * ${3:${TM_FILENAME_BASE}}.c - ${2:description} (kretprobe example)",
			" *",
			" * Copyright (C) ${4:${CURRENT_YEAR}} ${1:author}",
			" */",
			"",
			"#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt",
			"",
			"#include <linux/module.h>",
			"#include <linux/kernel.h>",
			"#include <linux/init.h>",
			"#include <linux/kprobes.h>",
			"#include <linux/ptrace.h>",
			"#include <linux/sched.h>",
			"#include <linux/string.h>",
			"#include <linux/time.h>",
			"",
			"static char target_func[64] = \"${5:vfs_read}\";",
			"module_param_string(target_func, target_func, sizeof(target_func), 0644);",
			"MODULE_PARM_DESC(target_func, \"Target function to probe\");",
			"",
			"static struct kretprobe rp = {",
			"\t.kp.symbol_name = target_func,",
			"\t.maxactive = 20,\t\t/* 最大活跃实例数 */",
			"\t.data_size = sizeof(ktime_t),\t/* 每个实例的私有数据大小 */",
			"};",
			"",
			"/* kretprobe entry handler: called when the probed function is entered */",
			"static int entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)",
			"{",
			"\tktime_t *entry_time = (ktime_t *)ri->data;",
			"",
			"\t*entry_time = ktime_get();",
			"",
			"\tpr_info(\"<%s> entry: pid=%d comm=%s\\n\",",
			"\t\trp.kp.symbol_name, current->pid, current->comm);",
			"",
			"\t/* 可以在这里记录函数参数 */",
			"\t/* 例如对于 vfs_read: */",
			"\t/*",
			"\t * struct file *file = (struct file *)regs->di;",
			"\t * size_t count = (size_t)regs->dx;",
			"\t * pr_info(\"vfs_read: count=%zu\\n\", count);",
			"\t */",
			"",
			"\treturn 0;",
			"}",
			"",
			"/* kretprobe return handler: called when the probed function returns */",
			"static int ret_handler(struct kretprobe_instance *ri, struct pt_regs *regs)",
			"{",
			"\tktime_t *entry_time = (ktime_t *)ri->data;",
			"\tktime_t exit_time, duration;",
			"\tlong ret_val = regs_return_value(regs);",
			"",
			"\texit_time = ktime_get();",
			"\tduration = ktime_sub(exit_time, *entry_time);",
			"",
			"\tpr_info(\"<%s> return: pid=%d comm=%s ret=%ld duration=%lld ns\\n\",",
			"\t\trp.kp.symbol_name, current->pid, current->comm,",
			"\t\tret_val, ktime_to_ns(duration));",
			"",
			"\treturn 0;",
			"}",
			"",
			"static int __init ${3:${TM_FILENAME_BASE}}_init(void)",
			"{",
			"\tint ret;",
			"",
			"\trp.entry_handler = entry_handler;",
			"\trp.handler = ret_handler;",
			"",
			"\tret = register_kretprobe(&rp);",
			"\tif (ret < 0) {",
			"\t\tpr_err(\"register_kretprobe failed, returned %d\\n\", ret);",
			"\t\treturn ret;",
			"\t}",
			"",
			"\tpr_info(\"Planted kretprobe at %p (symbol: %s)\\n\",",
			"\t\trp.kp.addr, rp.kp.symbol_name);",
			"\treturn 0;",
			"}",
			"",
			"static void __exit ${3:${TM_FILENAME_BASE}}_exit(void)",
			"{",
			"\tunregister_kretprobe(&rp);",
			"\tpr_info(\"kretprobe at %p unregistered, missed %d instances\\n\",",
			"\t\trp.kp.addr, rp.nmissed);",
			"}",
			"",
			"MODULE_LICENSE(\"GPL\");",
			"MODULE_AUTHOR(\"${1:author}\");",
			"MODULE_DESCRIPTION(\"${2:description} (kretprobe example with timing)\");",
			"",
			"module_init(${3:${TM_FILENAME_BASE}}_init);",
			"module_exit(${3:${TM_FILENAME_BASE}}_exit);"
		],
		"description": "Linux kernel module template with kretprobe for function entry/exit monitoring with timing analysis"
	},
	"Linux Kernel Module Makefile": {
		"scope": "makefile",
		"prefix": "kmodmake",
		"body": [
			"# Kernel module Makefile",
			"",
			"KDIR := /lib/modules/$(shell uname -r)/build",
			"PWD := $(shell pwd)",
			"MODULE_NAME := ${1:module_name}",
			"",
			"# Compiler flags for debugging (uncomment for debug build)",
			"# ccflags-y += -DDEBUG -g",
			"",
			"obj-m += $(MODULE_NAME).o",
			"",
			"# Multi-file modules (uncomment and modify if needed)",
			"# $(MODULE_NAME)-objs := file1.o file2.o",
			"",
			"CHECKPATCH := $(KDIR)/scripts/checkpatch.pl",
			"SRC := $(wildcard *.c *.h)",
			"",
			".PHONY: all clean checkpatch modules_install help info logs",
			".PHONY: insmod rmmod reload status",
			"",
			"all: checkpatch modules",
			"",
			"modules:",
			"\t@echo \"Building kernel module $(MODULE_NAME)...\"",
			"\tmake -C $(KDIR) M=$(PWD) modules",
			"\t@echo \"Build completed: $(MODULE_NAME).ko\"",
			"",
			"checkpatch:",
			"\t@echo \"Running checkpatch on source files...\"",
			"\t@if [ -f $(CHECKPATCH) ]; then \\",
			"\t\tfor file in $(SRC); do \\",
			"\t\t\techo \"Checking $$file...\"; \\",
			"\t\t\tperl $(CHECKPATCH) --no-tree --terse -f $$file || true; \\",
			"\t\tdone; \\",
			"\telse \\",
			"\t\techo \"checkpatch.pl not found: skipped\"; \\",
			"\tfi",
			"",
			"clean:",
			"\t@echo \"Cleaning build files...\"",
			"\tmake -C $(KDIR) M=$(PWD) clean",
			"\trm -f Module.symvers modules.order",
			"",
			"# Install module to system (requires root)",
			"modules_install: modules",
			"\tmake -C $(KDIR) M=$(PWD) modules_install",
			"\tdepmod -a",
			"",
			"# Load module",
			"insmod: modules",
			"\t@echo \"Loading module $(MODULE_NAME)...\"",
			"\t@if lsmod | grep -q '^$(MODULE_NAME) '; then \\",
			"\t\techo \"Module $(MODULE_NAME) already loaded, removing first...\"; \\",
			"\t\tsudo rmmod $(MODULE_NAME) 2>/dev/null || true; \\",
			"\tfi",
			"\tsudo insmod $(MODULE_NAME).ko",
			"\t@echo \"Module $(MODULE_NAME) loaded successfully\"",
			"\t@lsmod | grep '^$(MODULE_NAME) ' || echo \"Warning: Module not found in lsmod\"",
			"",
			"# Unload module",
			"rmmod:",
			"\t@echo \"Unloading module $(MODULE_NAME)...\"",
			"\t@if lsmod | grep -q '^$(MODULE_NAME) '; then \\",
			"\t\tsudo rmmod $(MODULE_NAME); \\",
			"\t\techo \"Module $(MODULE_NAME) unloaded successfully\"; \\",
			"\telse \\",
			"\t\techo \"Module $(MODULE_NAME) is not loaded\"; \\",
			"\tfi",
			"",
			"# Reload module (unload + load)",
			"reload: rmmod insmod",
			"",
			"# Show module status and info",
			"status:",
			"\t@echo \"=== Module Status ===\"",
			"\t@if lsmod | grep -q '^$(MODULE_NAME) '; then \\",
			"\t\techo \"✓ Module $(MODULE_NAME) is loaded:\"; \\",
			"\t\tlsmod | grep '^$(MODULE_NAME) '; \\",
			"\telse \\",
			"\t\techo \"✗ Module $(MODULE_NAME) is not loaded\"; \\",
			"\tfi",
			"",
			"# Show module information",
			"info:",
			"\t@echo \"=== Module Information ===\"",
			"\t@if [ -f $(MODULE_NAME).ko ]; then \\",
			"\t\tmodinfo $(MODULE_NAME).ko; \\",
			"\telse \\",
			"\t\techo \"Module $(MODULE_NAME).ko not found. Run 'make' first.\"; \\",
			"\tfi",
			"",
			"# Show recent kernel logs related to the module",
			"logs:",
			"\t@echo \"=== Recent kernel logs (last 20 lines, filtered) ===\"",
			"\t@dmesg | grep -i $(MODULE_NAME) | tail -20 || echo \"No logs found for $(MODULE_NAME)\"",
			"",
			"# Show help",
			"help:",
			"\t@echo \"Available targets:\"",
			"\t@echo \"  all           - Run checkpatch and build module (default)\"",
			"\t@echo \"  modules       - Build the kernel module\"",
			"\t@echo \"  checkpatch    - Run kernel coding style checker\"",
			"\t@echo \"  clean         - Clean build files\"",
			"\t@echo \"  modules_install - Install module to system\"",
			"\t@echo \"  insmod        - Load module into kernel\"",
			"\t@echo \"  rmmod         - Unload module from kernel\"",
			"\t@echo \"  reload        - Unload and reload module\"",
			"\t@echo \"  status        - Show module load status\"",
			"\t@echo \"  info          - Show module information\"",
			"\t@echo \"  logs          - Show recent kernel logs for module\"",
			"\t@echo \"  help          - Show this help message\"",
			"\t@echo \"\"",
			"\t@echo \"Module name: $(MODULE_NAME)\"",
			"\t@echo \"Kernel build dir: $(KDIR)\""
		],
		"description": "Comprehensive Makefile for Linux kernel modules with checkpatch, build, load/unload, status checking, debugging support, and help system"
	}
}